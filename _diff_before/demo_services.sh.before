#!/usr/bin/env bash
set -euo pipefail

ROOT="/home/xrh/qwen3_os_fault"
VENV="$ROOT/.venv_qwen3"
PY="$VENV/bin/python"
LOG_DIR="$ROOT/storage/logs"
PID_DIR="$ROOT/storage/pids"
INBOX="$ROOT/storage/tcp_inbox"
OUT="$ROOT/storage/tcp_out"
RUNS="$ROOT/storage/runs"

ensure_dirs() {
  mkdir -p "$LOG_DIR" "$PID_DIR" "$INBOX" "$OUT" "$RUNS"
}

activate_venv() {
  if [ ! -f "$VENV/bin/activate" ]; then
    echo "venv missing: $VENV" >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  source "$VENV/bin/activate"
  export PYTHONUNBUFFERED=1
}

pid_alive() {
  local pidfile="$1"
  local pid
  [ -f "$pidfile" ] || return 1
  pid="$(cat "$pidfile" 2>/dev/null || true)"
  [ -n "$pid" ] || return 1
  kill -0 "$pid" 2>/dev/null
}

start_one() {
  local name="$1"
  local pidfile="$2"
  local logfile="$3"
  shift 3
  if pid_alive "$pidfile"; then
    echo "$name already running pid=$(cat "$pidfile")"
    return 0
  fi
  nohup "$@" >>"$logfile" 2>&1 &
  echo "$!" > "$pidfile"
  echo "$name started pid=$!"
}

wait_stop() {
  local pid="$1"
  local i=0
  while kill -0 "$pid" 2>/dev/null; do
    i=$((i + 1))
    [ "$i" -gt 3 ] && return 1
    sleep 1
  done
  return 0
}

stop_one() {
  local name="$1"
  local pidfile="$2"
  if ! pid_alive "$pidfile"; then
    echo "$name not running"
    rm -f "$pidfile"
    return 0
  fi
  local pid
  pid="$(cat "$pidfile" 2>/dev/null || true)"
  echo "stopping $name pid=$pid"
  kill "$pid" 2>/dev/null || true
  if ! wait_stop "$pid"; then
    echo "killing $name pid=$pid"
    kill -9 "$pid" 2>/dev/null || true
  fi
  rm -f "$pidfile"
}

check_port() {
  local port="$1"
  ss -lntp | grep -q ":$port" 2>/dev/null
}

status_one() {
  local name="$1"
  local pidfile="$2"
  local port="$3"
  local logfile="$4"
  local status="down"
  if pid_alive "$pidfile"; then
    status="up"
  fi
  local listen="no"
  if [ -n "$port" ] && check_port "$port"; then
    listen="yes"
  fi
  echo "$name: pid=$(cat "$pidfile" 2>/dev/null || echo '-') alive=$status listen=$listen"
  tail -n 5 "$logfile" 2>/dev/null || true
}

start_all() {
  ensure_dirs
  activate_venv
  start_one "ingest" "$PID_DIR/ingest.pid" "$LOG_DIR/ingest.log" "$PY" "$ROOT/server_B/tcp/tcp_ingest_server.py" --host 0.0.0.0 --port 18080 --inbox "$INBOX"
  start_one "actions" "$PID_DIR/actions.pid" "$LOG_DIR/actions.log" "$PY" "$ROOT/server_B/tcp/tcp_actions_server.py" --host 0.0.0.0 --port 28081 --out "$OUT"
  start_one "watcher" "$PID_DIR/watcher.pid" "$LOG_DIR/watcher.log" "$PY" "$ROOT/server_B/tcp/watch_and_infer.py" --inbox "$INBOX" --out "$OUT" --runs_root "$RUNS" --poll_sec 2

  sleep 1
  local ok=1
  if ! pid_alive "$PID_DIR/ingest.pid"; then ok=0; fi
  if ! pid_alive "$PID_DIR/actions.pid"; then ok=0; fi
  if ! pid_alive "$PID_DIR/watcher.pid"; then ok=0; fi
  if ! check_port 18080 || ! check_port 28081; then ok=0; fi
  if [ "$ok" -ne 1 ]; then
    echo "start failed, logs tail:"
    tail -n 50 "$LOG_DIR/ingest.log" 2>/dev/null || true
    tail -n 50 "$LOG_DIR/actions.log" 2>/dev/null || true
    tail -n 50 "$LOG_DIR/watcher.log" 2>/dev/null || true
    exit 1
  fi
  echo "ports ok: 18080/28081, pids alive"
}

stop_all() {
  stop_one "watcher" "$PID_DIR/watcher.pid"
  stop_one "actions" "$PID_DIR/actions.pid"
  stop_one "ingest" "$PID_DIR/ingest.pid"
}

status_all() {
  status_one "ingest" "$PID_DIR/ingest.pid" "18080" "$LOG_DIR/ingest.log"
  status_one "actions" "$PID_DIR/actions.pid" "28081" "$LOG_DIR/actions.log"
  status_one "watcher" "$PID_DIR/watcher.pid" "" "$LOG_DIR/watcher.log"
}

logs_all() {
  tail -n 80 "$LOG_DIR/ingest.log" 2>/dev/null || true
  tail -n 80 "$LOG_DIR/actions.log" 2>/dev/null || true
  tail -n 80 "$LOG_DIR/watcher.log" 2>/dev/null || true
}

case "${1:-}" in
  start) start_all ;;
  stop) stop_all ;;
  restart) stop_all; start_all ;;
  status) status_all ;;
  logs) logs_all ;;
  *)
    echo "Usage: $0 {start|stop|restart|status|logs}" >&2
    exit 2
    ;;
 esac
